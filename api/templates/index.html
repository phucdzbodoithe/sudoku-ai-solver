<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Sudoku AI Team</title>
    <style>
        /* CSS Giao di·ªán - Gi·ªØ nguy√™n cho g·ªçn */
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f2f5; padding: 20px; }
        .grid { display: grid; grid-template-columns: repeat(9, 50px); border: 4px solid #34495e; }
        .grid input { width: 50px; height: 50px; text-align: center; font-size: 20px; border: 1px solid #ccc; outline: none; }
        
        /* K·∫ª l∆∞·ªõi ƒë·∫≠m 3x3 */
        .grid input:nth-child(3n) { border-right: 3px solid #34495e; }
        .grid input:nth-child(9n) { border-right: 1px solid #ccc; }
        .grid input:nth-child(n+19):nth-child(-n+27), .grid input:nth-child(n+46):nth-child(-n+54) { border-bottom: 3px solid #34495e; }

        /* M√†u s·∫Øc k·∫øt qu·∫£ */
        .readonly { background: #ecf0f1; font-weight: bold; color: #2c3e50; }
        .correct { color: #27ae60 !important; font-weight: bold; } /* Xanh l√°: ƒê√∫ng */
        .wrong { background: #ffcccc !important; color: #c0392b !important; } /* ƒê·ªè: Sai */

        .controls, .buttons { margin: 15px 0; display: flex; gap: 10px; }
        button { padding: 10px 20px; cursor: pointer; border-radius: 5px; border: none; color: white; font-weight: bold; }
        .btn-gen { background: #2980b9; }
        .btn-check { background: #8e44ad; } /* N√∫t T√≠m: N·ªôp b√†i */
        .btn-solve { background: #27ae60; }
        .btn-clear { background: #e67e22; }
        .status { margin-top: 10px; font-weight: bold; color: #34495e; }
    </style>
</head>
<body>
    <h1>Sudoku Solver - Nh√≥m AI</h1>
    
    <div class="controls">
        <select id="level">
            <option value="easy">D·ªÖ</option>
            <option value="medium" selected>Trung B√¨nh</option>
            <option value="hard">Kh√≥</option>
            <option value="expert">Si√™u Kh√≥</option>
        </select>
        <button class="btn-gen" onclick="gen()">Sinh ƒê·ªÅ M·ªõi</button>
    </div>

    <div class="grid" id="grid"></div>

    <div class="buttons">
        <button class="btn-clear" onclick="clearBoard()">Nh·∫≠p L·∫°i</button>
        <button class="btn-check" onclick="check()">N·ªôp B√†i</button>
        <button class="btn-solve" onclick="solve()">AI Gi·∫£i Gi√∫p</button>
    </div>
    <div class="status" id="status">S·∫µn s√†ng...</div>

    <script>
        const grid = document.getElementById('grid');
        const status = document.getElementById('status');
        const inputs = [];
        let solution = []; // Bi·∫øn ch·ª©a ƒë√°p √°n (ƒë∆∞·ª£c Server g·ª≠i v·ªÅ)

        // 1. T·∫°o b√†n c·ªù 81 √¥
        for(let i=0; i<81; i++) {
            let inp = document.createElement('input');
            inp.oninput = function() { 
                this.value = this.value.replace(/[^1-9]/g,''); 
                this.classList.remove('wrong', 'correct'); // Nh·∫≠p l·∫°i th√¨ x√≥a m√†u c≈©
            };
            grid.appendChild(inp);
            inputs.push(inp);
        }

        // 2. H√†m g·ªçi Server sinh ƒë·ªÅ
        async function gen() {
            clearBoard();
            status.innerText = "ƒêang t·∫£i ƒë·ªÅ...";
            let lv = document.getElementById('level').value;
            let res = await fetch(`/generate?level=${lv}`);
            let data = await res.json();
            
            // L∆∞u ƒë√°p √°n b√≠ m·∫≠t v√†o bi·∫øn solution
            solution = data.solution.flat(); 
            
            // Hi·ªÉn th·ªã ƒë·ªÅ b√†i
            let board = data.board.flat();
            board.forEach((val, i) => {
                if(val !== 0) {
                    inputs[i].value = val;
                    inputs[i].readOnly = true;
                    inputs[i].classList.add('readonly');
                }
            });
            status.innerText = "ƒê√£ c√≥ ƒë·ªÅ!";
        }

        // 3. H√†m ch·∫•m ƒëi·ªÉm (Frontend t·ª± ch·∫•m d·ª±a tr√™n ƒë√°p √°n c√≥ s·∫µn)
        function check() {
            if(solution.length === 0) return alert("Ch∆∞a c√≥ ƒë·ªÅ b√†i!");
            let err = 0;
            inputs.forEach((inp, i) => {
                if(!inp.readOnly && inp.value) {
                    // So s√°nh s·ªë ng∆∞·ªùi nh·∫≠p v·ªõi ƒë√°p √°n g·ªëc (solution)
                    if(parseInt(inp.value) !== solution[i]) {
                        inp.classList.add('wrong');
                        err++;
                    } else {
                        inp.classList.add('correct');
                    }
                }
            });
            status.innerText = err === 0 ? "Xu·∫•t s·∫Øc! ƒê√∫ng h·∫øt r·ªìi üéâ" : `B·∫°n sai ${err} √¥ r·ªìi!`;
        }

        // 4. H√†m g·ªçi AI gi·∫£i h·ªô (n·∫øu b√≠ qu√°)
        async function solve() {
            let board = [], row = [];
            inputs.forEach((inp, i) => {
                row.push(inp.value ? parseInt(inp.value) : 0);
                if((i+1)%9===0) { board.push(row); row=[]; }
            });
            
            status.innerText = "AI ƒëang nghƒ©...";
            let res = await fetch('/solve', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({board})
            });
            let data = await res.json();
            
            if(data.status === 'success') {
                data.board.flat().forEach((val, i) => {
                    if(!inputs[i].value) {
                        inputs[i].value = val;
                        inputs[i].classList.add('correct');
                    }
                });
                status.innerText = "AI ƒë√£ gi·∫£i xong!";
            } else {
                status.innerText = "V√¥ nghi·ªám (Ki·ªÉm tra l·∫°i s·ªë b·∫°n nh·∫≠p)!";
            }
        }

        function clearBoard() {
            inputs.forEach(inp => {
                inp.value = ''; inp.readOnly = false; inp.className = '';
            });
            solution = [];
            status.innerText = "S·∫µn s√†ng...";
        }
    </script>
</body>
</html>
                    let flatBoard = data.board.flat();
                    for (let i = 0; i < 81; i++) {
                        let val = flatBoard[i];
                        if (val !== 0) {
                            inputs[i].value = val;
                            inputs[i].style.fontWeight = "bold";
                            inputs[i].readOnly = true;
                            inputs[i].style.backgroundColor = "#ecf0f1";
                        }
                    }
                    statusText.innerText = "ƒê√£ sinh ƒë·ªÅ m·ªõi. H√£y b·∫•m 'AI Gi·∫£i Ngay'";
                }
            } catch (error) { statusText.innerText = "L·ªói k·∫øt n·ªëi Server!"; }
        }

        async function solveSudoku() {
            let board = [];
            let row = [];
            
            // L·∫•y d·ªØ li·ªáu
            for (let i = 0; i < 81; i++) {
                let val = inputs[i].value;
                row.push(val === "" ? 0 : parseInt(val));
                if ((i + 1) % 9 === 0) { board.push(row); row = []; }
            }

            statusText.innerText = "AI ƒëang suy nghƒ©...";
            
            // --- B·∫ÆT ƒê·∫¶U B·∫§M GI·ªú ---
            let startTime = performance.now(); 

            try {
                const response = await fetch('/solve', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ board: board })
                });
                const data = await response.json();

                // --- K·∫æT TH√öC B·∫§M GI·ªú ---
                let endTime = performance.now();
                let timeTaken = ((endTime - startTime) / 1000).toFixed(4); // L·∫•y 4 s·ªë l·∫ª sau d·∫•u ph·∫©y

                if (data.status === 'success') {
                    let flatBoard = data.board.flat();
                    for (let i = 0; i < 81; i++) {
                        if (inputs[i].value == "") {
                            inputs[i].value = flatBoard[i];
                            inputs[i].style.color = "#27ae60"; 
                            inputs[i].style.fontWeight = "bold";
                            inputs[i].style.opacity = 0;
                            setTimeout(() => inputs[i].style.opacity = 1, i * 10); 
                        }
                    }
                    // Hi·ªÉn th·ªã th·ªùi gian ra m√†n h√¨nh
                    statusText.innerHTML = `ƒê√£ gi·∫£i xong trong <span class="time-highlight">${timeTaken}s</span>`;
                } else { 
                    statusText.innerText = "Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i! (Ki·ªÉm tra l·∫°i ƒë·ªÅ b√†i)";
                    alert("Kh√¥ng t√¨m th·∫•y l·ªùi gi·∫£i! B·∫°n h√£y ki·ªÉm tra l·∫°i c√°c s·ªë ƒë√£ nh·∫≠p xem c√≥ b·ªã tr√πng l·∫∑p kh√¥ng."); 
                }
            } catch (error) { 
                statusText.innerText = "L·ªói k·∫øt n·ªëi!";
            }
        }

        function clearGrid() {
            inputs.forEach(input => {
                input.value = '';
                input.style.backgroundColor = "white";
                input.readOnly = false;
                input.style.color = "#2c3e50";
                input.style.fontWeight = "normal";
                input.style.opacity = 1;
            });
            inputs[0].focus();
            statusText.innerText = "S·∫µn s√†ng nh·∫≠p ƒë·ªÅ b√†i...";
        }
    </script>
</body>

</html>
